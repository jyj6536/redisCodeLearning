# 主从复制

主从复制是redis高可用的基础。主要有以下作用：

1. 数据备份和灾难恢复：通过主从同步，可以将主节点的数据实时备份到从节点上，当主节点发生故障时，可以快速切换到从节点继续提供服务，实现灾难恢复。
2. 提高读取性能：从节点可以处理读取请求，分担主节点的读取负载，提高系统整体的读取性能。
3. 扩展系统容量：通过搭建多个从节点，可以将读取请求均匀地分布到不同的从节点上，从而扩展系统的读取容量。
4. 支持读写分离：在实际应用中，可以让主节点处理写操作，而从节点处理读操作，从而实现读写分离，进一步提升系统的性能和稳定性。

## 主从握手

要建立主从复制的关系，首先要从节点发起流程，可以在从节点执行 `REPLICAOF <host port | NO ONE>` 命令。如果指定 host 与 port 则尝试成为被指定的服务器的从节点，如果参数为 `NO ONE` 则会使当前服务器从节点状态转换为 master 状态。在配置文件中添加 `REPLICAOF <host port>` 也可以使redis在启动后成为从节点。

全局变量server中有一些与主从复制密切相关的属性：

+ masterhost：从节点中为主节点的ip，主节点中为NULL

+ masterport：主节点的端口号

+ repl_state：用于从节点，标志当前从节点主从复制的状态

  ```C
  //src/server.h
  typedef enum {
      REPL_STATE_NONE = 0,            /* No active replication */
      REPL_STATE_CONNECT,             /* Must connect to master */
      REPL_STATE_CONNECTING,          /* Connecting to master */
      /* --- Handshake states, must be ordered --- */
      REPL_STATE_RECEIVE_PING_REPLY,  /* Wait for PING reply */
      REPL_STATE_SEND_HANDSHAKE,      /* Send handshake sequence to master */
      REPL_STATE_RECEIVE_AUTH_REPLY,  /* Wait for AUTH reply */
      REPL_STATE_RECEIVE_PORT_REPLY,  /* Wait for REPLCONF reply */
      REPL_STATE_RECEIVE_IP_REPLY,    /* Wait for REPLCONF reply */
      REPL_STATE_RECEIVE_CAPA_REPLY,  /* Wait for REPLCONF reply */
      REPL_STATE_SEND_PSYNC,          /* Send PSYNC */
      REPL_STATE_RECEIVE_PSYNC_REPLY, /* Wait for PSYNC reply */
      /* --- End of handshake states --- */
      REPL_STATE_TRANSFER,        /* Receiving .rdb from master */
      REPL_STATE_CONNECTED,       /* Connected to master */
  } repl_state;
  ```

REPLICAOF命令的命令处理函数为replicaofCommand，其中执行的逻辑为：

1. 如果参数为 `no one` 则将当前服务器设置为主节点，取消原来的主从复制关系
2. 否则调用replicationSetMaster函数，与给定的服务器建立主从复制关系

```C
//src/replication.c
void replicationSetMaster(char *ip, int port) {
    int was_master = server.masterhost == NULL;//判断当前是否为主节点

    sdsfree(server.masterhost);
    server.masterhost = NULL;
    if (server.master) {
        freeClient(server.master);
    }
    disconnectAllBlockedClients(); /* Clients blocked in master, now slave. *///当一个主节点变成从节点时，原先在列表操作中被阻止的客户端再次访问可能不安全，因此需要调用该函数。函数的语义是向客户端发送一个-UNBLOCKED错误，并同时将其断开连接。这意味着客户端收到错误消息后会被强制断开连接。

    /* Setting masterhost only after the call to freeClient since it calls
     * replicationHandleMasterDisconnection which can trigger a re-connect
     * directly from within that call. */
    server.masterhost = sdsnew(ip);
    server.masterport = port;

    /* Update oom_score_adj */
    setOOMScoreAdj(-1);//设置/proc/self/oom_score_adj

    /* Here we don't disconnect with replicas, since they may hopefully be able
     * to partially resync with us. We will disconnect with replicas and force
     * them to resync with us when changing replid on partially resync with new
     * master, or finishing transferring RDB and preparing loading DB on full
     * sync with new master. */

    cancelReplicationHandshake(0);//如果当前节点处在握手流程中，则取消之
    /* Before destroying our master state, create a cached master using
     * our own parameters, to later PSYNC with the new master. */
    if (was_master) {
        replicationDiscardCachedMaster();
        replicationCacheMasterUsingMyself();//如果是主节点，则将server.master->replid修改为当前节点的server.replid，保存server.master_repl_offset为server.master_initial_offset，并将server.master保存为server.cached_master用于后续的PSYNC
    }

    /* Fire the role change modules event. */
    moduleFireServerEvent(REDISMODULE_EVENT_REPLICATION_ROLE_CHANGED,
                          REDISMODULE_EVENT_REPLROLECHANGED_NOW_REPLICA,
                          NULL);

    /* Fire the master link modules event. */
    if (server.repl_state == REPL_STATE_CONNECTED)
        moduleFireServerEvent(REDISMODULE_EVENT_MASTER_LINK_CHANGE,
                              REDISMODULE_SUBEVENT_MASTER_LINK_DOWN,
                              NULL);

    server.repl_state = REPL_STATE_CONNECT;//握手流程的初始状态
    serverLog(LL_NOTICE,"Connecting to MASTER %s:%d",
        server.masterhost, server.masterport);
    connectWithMaster();//向主节点发起连接建立请求
}

//src/replication.c
int connectWithMaster(void) {
    server.repl_transfer_s = connCreate(connTypeOfReplication());
    if (connConnect(server.repl_transfer_s, server.masterhost, server.masterport,
                server.bind_source_addr, syncWithMaster) == C_ERR) {//建立到主节点的连接，这里调用的是connSocketConnect，连接建立成功后的回调函数为syncWithMaster（可写事件触发）
        serverLog(LL_WARNING,"Unable to connect to MASTER: %s",
                connGetLastError(server.repl_transfer_s));
        connClose(server.repl_transfer_s);
        server.repl_transfer_s = NULL;
        return C_ERR;
    }


    server.repl_transfer_lastio = server.unixtime;
    server.repl_state = REPL_STATE_CONNECTING;//更新握手状态
    serverLog(LL_NOTICE,"MASTER <-> REPLICA sync started");
    return C_OK;
}
```

到目前位置，从节点已经发起了与主节点的连接，从节点状态为 `REPL_STATE_CONNECTING`，连接建立成功后触发连接fd的可写事件并调用回调函数 `syncWithMaster`

````C
//src/replication.c
/*
	根据repl_state的状态进行状态转移
*/
void syncWithMaster(connection *conn) {
    char tmpfile[256], *err = NULL;
    int dfd = -1, maxtries = 5;
    int psync_result;

    /* If this event fired after the user turned the instance into a master
     * with SLAVEOF NO ONE we must just return ASAP. */
    if (server.repl_state == REPL_STATE_NONE) {//检查当前服务器是否退出从节点状态，退出则立即返回
        connClose(conn);
        return;
    }

    /* Check for errors in the socket: after a non blocking connect() we
     * may find that the socket is in error state. */
    if (connGetState(conn) != CONN_STATE_CONNECTED) {//检查连接是否出错
        serverLog(LL_WARNING,"Error condition on socket for SYNC: %s",
                connGetLastError(conn));
        goto error;
    }

    /* Send a PING to check the master is able to reply without errors. */
    if (server.repl_state == REPL_STATE_CONNECTING) {//如果当前处于REPL_STATE_CONNECTING状态，则发送PING进入REPL_STATE_RECEIVE_PING_REPLY状态，此时注册conn的读事件处理函数为syncWithMaster以在主节点发送应答后继续后续处理
        serverLog(LL_NOTICE,"Non blocking connect for SYNC fired the event.");
        /* Delete the writable event so that the readable event remains
         * registered and we can wait for the PONG reply. */
        connSetReadHandler(conn, syncWithMaster);
        connSetWriteHandler(conn, NULL);
        server.repl_state = REPL_STATE_RECEIVE_PING_REPLY;
        /* Send the PING, don't check for errors at all, we have the timeout
         * that will take care about this. */
        err = sendCommand(conn,"PING",NULL);
        if (err) goto write_error;
        return;
    }

    /* Receive the PONG command. */
    if (server.repl_state == REPL_STATE_RECEIVE_PING_REPLY) {//已发送PING，收到主节点应答
        err = receiveSynchronousResponse(conn);//读取主节点应答，err存放读到的数据

        /* The master did not reply */
        if (err == NULL) goto no_response_error;

        /* We accept only two replies as valid, a positive +PONG reply
         * (we just check for "+") or an authentication error.
         * Note that older versions of Redis replied with "operation not
         * permitted" instead of using a proper error code, so we test
         * both. */
        if (err[0] != '+' &&
            strncmp(err,"-NOAUTH",7) != 0 &&
            strncmp(err,"-NOPERM",7) != 0 &&
            strncmp(err,"-ERR operation not permitted",28) != 0)
        {
            serverLog(LL_WARNING,"Error reply to PING from master: '%s'",err);
            sdsfree(err);
            goto error;
        } else {
            serverLog(LL_NOTICE,
                "Master replied to PING, replication can continue...");
        }
        sdsfree(err);
        err = NULL;
        server.repl_state = REPL_STATE_SEND_HANDSHAKE;//检查受到的应答无误之后，状态转换为REPL_STATE_SEND_HANDSHAKE
    }

    if (server.repl_state == REPL_STATE_SEND_HANDSHAKE) {//开始握手
        /* AUTH with the master if required. */
        if (server.masterauth) {//首先检查是否需要认证，需要则发送AUTH命令
            char *args[3] = {"AUTH",NULL,NULL};
            size_t lens[3] = {4,0,0};
            int argc = 1;
            if (server.masteruser) {
                args[argc] = server.masteruser;
                lens[argc] = strlen(server.masteruser);
                argc++;
            }
            args[argc] = server.masterauth;
            lens[argc] = sdslen(server.masterauth);
            argc++;
            err = sendCommandArgv(conn, argc, args, lens);
            if (err) goto write_error;
        }

        /* Set the slave port, so that Master's INFO command can list the
         * slave listening port correctly. */
        {//向主节点发送本节点的端口号
            int port;
            if (server.slave_announce_port)
                port = server.slave_announce_port;
            else if (server.tls_replication && server.tls_port)
                port = server.tls_port;
            else
                port = server.port;
            sds portstr = sdsfromlonglong(port);
            err = sendCommand(conn,"REPLCONF",
                    "listening-port",portstr, NULL);
            sdsfree(portstr);
            if (err) goto write_error;
        }

        /* Set the slave ip, so that Master's INFO command can list the
         * slave IP address port correctly in case of port forwarding or NAT.
         * Skip REPLCONF ip-address if there is no slave-announce-ip option set. */
        if (server.slave_announce_ip) {//向主节点发送本节点的ip地址
            err = sendCommand(conn,"REPLCONF",
                    "ip-address",server.slave_announce_ip, NULL);
            if (err) goto write_error;
        }

        /* Inform the master of our (slave) capabilities.
         *
         * EOF: supports EOF-style RDB transfer for diskless replication.
         * PSYNC2: supports PSYNC v2, so understands +CONTINUE <new repl ID>.
         *
         * The master will ignore capabilities it does not understand. */
        err = sendCommand(conn,"REPLCONF",//向主节点发送本节点的capability
                "capa","eof","capa","psync2",NULL);
        if (err) goto write_error;

        server.repl_state = REPL_STATE_RECEIVE_AUTH_REPLY;
        return;
    }
	//这里判断是否需要认证，不需要认证则直接将状态转换为REPL_STATE_RECEIVE_PORT_REPLY
    if (server.repl_state == REPL_STATE_RECEIVE_AUTH_REPLY && !server.masterauth)
        server.repl_state = REPL_STATE_RECEIVE_PORT_REPLY;

    /* Receive AUTH reply. */
    if (server.repl_state == REPL_STATE_RECEIVE_AUTH_REPLY) {//如果需要认证，则判读认证是否成功
        err = receiveSynchronousResponse(conn);
        if (err == NULL) goto no_response_error;
        if (err[0] == '-') {
            serverLog(LL_WARNING,"Unable to AUTH to MASTER: %s",err);
            sdsfree(err);
            goto error;
        }
        sdsfree(err);
        err = NULL;
        server.repl_state = REPL_STATE_RECEIVE_PORT_REPLY;//认证成功，状态转换为REPL_STATE_RECEIVE_PORT_REPLY
        return;
    }

    /* Receive REPLCONF listening-port reply. */
    /*...*/
	
    if (server.repl_state == REPL_STATE_RECEIVE_IP_REPLY && !server.slave_announce_ip)
        server.repl_state = REPL_STATE_RECEIVE_CAPA_REPLY;

    /* Receive REPLCONF ip-address reply. */
    /*...*/

    /* Receive CAPA reply. */
    if (server.repl_state == REPL_STATE_RECEIVE_CAPA_REPLY) {
        /*...*/
        server.repl_state = REPL_STATE_SEND_PSYNC;//主节点成功响应REPLCONF之后，状态转换为REPL_STATE_SEND_PSYNC
    }

    /* Try a partial resynchronization. If we don't have a cached master
     * slaveTryPartialResynchronization() will at least try to use PSYNC
     * to start a full resynchronization so that we get the master replid
     * and the global offset, to try a partial resync at the next
     * reconnection attempt. */
    if (server.repl_state == REPL_STATE_SEND_PSYNC) {//这里，开始同步流程
        if (slaveTryPartialResynchronization(conn,0) == PSYNC_WRITE_ERROR) {//该函数负责全量同步或者部分同步，第二个参数决定是发送请求还是读取响应，这里为0表示读取发送请求
            err = sdsnew("Write error sending the PSYNC command.");
            abortFailover("Write error to failover target");
            goto write_error;
        }
        server.repl_state = REPL_STATE_RECEIVE_PSYNC_REPLY;//发送请求成功，状态转换为REPL_STATE_RECEIVE_PSYNC_REPLY
        return;
    }

    /* If reached this point, we should be in REPL_STATE_RECEIVE_PSYNC_REPLY. */
    if (server.repl_state != REPL_STATE_RECEIVE_PSYNC_REPLY) {
        serverLog(LL_WARNING,"syncWithMaster(): state machine error, "
                             "state should be RECEIVE_PSYNC but is %d",
                             server.repl_state);
        goto error;
    }

    psync_result = slaveTryPartialResynchronization(conn,1);//第二个参数为1，读取PSYNC响应
    if (psync_result == PSYNC_WAIT_REPLY) return; /* Try again later... */

    /* Check the status of the planned failover. We expect PSYNC_CONTINUE,
     * but there is nothing technically wrong with a full resync which
     * could happen in edge cases. */
    if (server.failover_state == FAILOVER_IN_PROGRESS) {
        if (psync_result == PSYNC_CONTINUE || psync_result == PSYNC_FULLRESYNC) {
            clearFailoverState();
        } else {
            abortFailover("Failover target rejected psync request");
            return;
        }
    }

    /* If the master is in an transient error, we should try to PSYNC
     * from scratch later, so go to the error path. This happens when
     * the server is loading the dataset or is not connected with its
     * master and so forth. */
    if (psync_result == PSYNC_TRY_LATER) goto error;

    /* Note: if PSYNC does not return WAIT_REPLY, it will take care of
     * uninstalling the read handler from the file descriptor. */

    if (psync_result == PSYNC_CONTINUE) {//这里说明部从节点的状态进入REPL_STATE_CONNECTED，开始进入复制阶段
        serverLog(LL_NOTICE, "MASTER <-> REPLICA sync: Master accepted a Partial Resynchronization.");
        if (server.supervised_mode == SUPERVISED_SYSTEMD) {
            redisCommunicateSystemd("STATUS=MASTER <-> REPLICA sync: Partial Resynchronization accepted. Ready to accept connections in read-write mode.\n");
        }
        return;
    }

    /* Fall back to SYNC if needed. Otherwise psync_result == PSYNC_FULLRESYNC
     * and the server.master_replid and master_initial_offset are
     * already populated. */
    if (psync_result == PSYNC_NOT_SUPPORTED) {//主节点不支持PSYNC协议，回退到SYNC协议
        serverLog(LL_NOTICE,"Retrying with SYNC...");
        if (connSyncWrite(conn,"SYNC\r\n",6,server.repl_syncio_timeout*1000) == -1) {
            serverLog(LL_WARNING,"I/O error writing to MASTER: %s",
                connGetLastError(conn));
            goto error;
        }
    }

    /* Prepare a suitable temp file for bulk transfer */
    if (!useDisklessLoad()) {//这里检查是否启用无盘加载的方式处理主节点发送的RDB数据，受repl-diskless-load配置项的影响，该配置项有3个取值1.disabled 数据先持久化到磁盘，再加载到内存；2.on-empty-db 从节点数据库为空则采用无盘加载的方式；3.swapdb 创建一个临时db用于数据加载，加载完成后在切换为主db
        while(maxtries--) {
            snprintf(tmpfile,256,
                "temp-%d.%ld.rdb",(int)server.unixtime,(long int)getpid());
            dfd = open(tmpfile,O_CREAT|O_WRONLY|O_EXCL,0644);
            if (dfd != -1) break;
            sleep(1);
        }
        if (dfd == -1) {
            serverLog(LL_WARNING,"Opening the temp file needed for MASTER <-> REPLICA synchronization: %s",strerror(errno));
            goto error;
        }
        server.repl_transfer_tmpfile = zstrdup(tmpfile);
        server.repl_transfer_fd = dfd;
    }

    /* Setup the non blocking download of the bulk file. */
    if (connSetReadHandler(conn, readSyncBulkPayload)//设置conn的读事件处理函数为readSyncBulkPayload，开始进行全量同步
            == C_ERR)
    {
        char conninfo[CONN_INFO_LEN];
        serverLog(LL_WARNING,
            "Can't create readable event for SYNC: %s (%s)",
            strerror(errno), connGetInfo(conn, conninfo, sizeof(conninfo)));
        goto error;
    }

    server.repl_state = REPL_STATE_TRANSFER;//进入全量同步状态
    server.repl_transfer_size = -1;
    server.repl_transfer_read = 0;
    server.repl_transfer_last_fsync_off = 0;
    server.repl_transfer_lastio = server.unixtime;
    return;

no_response_error: /* Handle receiveSynchronousResponse() error when master has no reply */
    serverLog(LL_WARNING, "Master did not respond to command during SYNC handshake");
    /* Fall through to regular error handling */

error:
    if (dfd != -1) close(dfd);
    connClose(conn);
    server.repl_transfer_s = NULL;
    if (server.repl_transfer_fd != -1)
        close(server.repl_transfer_fd);
    if (server.repl_transfer_tmpfile)
        zfree(server.repl_transfer_tmpfile);
    server.repl_transfer_tmpfile = NULL;
    server.repl_transfer_fd = -1;
    server.repl_state = REPL_STATE_CONNECT;
    return;

write_error: /* Handle sendCommand() errors. */
    serverLog(LL_WARNING,"Sending command to master in replication handshake: %s", err);
    sdsfree(err);
    goto error;
}
````

## 主从同步

从节点进入 `REPL_STATE_SEND_PSYNC` 状态后会调用 `slaveTryPartialResynchronization` 开启同步流程。该函数同时用于发送请求和接收响应，通过第二个参数区分

```C
//src/replication.c
/*
该函数的返回值如下：
PSYNC_CONTINUE：如果PSYNC命令成功并且我们可以继续。
PSYNC_FULLRESYNC：如果支持PSYNC但需要进行完全重新同步。在这种情况下，主节点的replid和全局复制偏移量将被保存。
PSYNC_NOT_SUPPORTED：如果服务器不支持PSYNC，并且调用方应该回退到SYNC。
PSYNC_WRITE_ERROR：写入命令到套接字时发生错误。
PSYNC_WAIT_REPLY：设置read_reply为1后，再次调用该函数等待回复。
PSYNC_TRY_LATER：主节点目前处于短暂错误条件中，稍后再尝试。
*/
int slaveTryPartialResynchronization(connection *conn, int read_reply) {
    char *psync_replid;
    char psync_offset[32];
    sds reply;

    /* Writing half */
    if (!read_reply) {//read_reply不为0则发送请求
        /* Initially set master_initial_offset to -1 to mark the current
         * master replid and offset as not valid. Later if we'll be able to do
         * a FULL resync using the PSYNC command we'll set the offset at the
         * right value, so that this information will be propagated to the
         * client structure representing the master into server.master. */
        server.master_initial_offset = -1;

        if (server.cached_master) {//根据cached_master是否为null决定进行部分同步还是全量同步
            psync_replid = server.cached_master->replid;//这里进行部分同步，replid和offset从之前缓存的server.cached_master获取
            snprintf(psync_offset,sizeof(psync_offset),"%lld", server.cached_master->reploff+1);
            serverLog(LL_NOTICE,"Trying a partial resynchronization (request %s:%s).", psync_replid, psync_offset);
        } else {
            serverLog(LL_NOTICE,"Partial resynchronization not possible (no cached master)");
            psync_replid = "?";
            memcpy(psync_offset,"-1",3);//这里发送PSYNC ? -1 请求进行全量同步
        }

        /* Issue the PSYNC command, if this is a master with a failover in
         * progress then send the failover argument to the replica to cause it
         * to become a master *///发送PSYNC命令
        if (server.failover_state == FAILOVER_IN_PROGRESS) {
            reply = sendCommand(conn,"PSYNC",psync_replid,psync_offset,"FAILOVER",NULL);
        } else {
            reply = sendCommand(conn,"PSYNC",psync_replid,psync_offset,NULL);
        }

        if (reply != NULL) {
            serverLog(LL_WARNING,"Unable to send PSYNC to master: %s",reply);
            sdsfree(reply);
            connSetReadHandler(conn, NULL);
            return PSYNC_WRITE_ERROR;
        }
        return PSYNC_WAIT_REPLY;
    }

    /* Reading half *///这里读取请求
    reply = receiveSynchronousResponse(conn);
    /* Master did not reply to PSYNC */
    if (reply == NULL) {
        connSetReadHandler(conn, NULL);
        serverLog(LL_WARNING, "Master did not reply to PSYNC, will try later");
        return PSYNC_TRY_LATER;
    }

    if (sdslen(reply) == 0) {
        /* The master may send empty newlines after it receives PSYNC
         * and before to reply, just to keep the connection alive. */
        sdsfree(reply);
        return PSYNC_WAIT_REPLY;
    }

    connSetReadHandler(conn, NULL);

    if (!strncmp(reply,"+FULLRESYNC",11)) {//如果主节点返回+FULLRESYNC则表明主节点要求全量同步
        char *replid = NULL, *offset = NULL;

        /* FULL RESYNC, parse the reply in order to extract the replid
         * and the replication offset. */
        replid = strchr(reply,' ');
        if (replid) {
            replid++;
            offset = strchr(replid,' ');
            if (offset) offset++;
        }
        if (!replid || !offset || (offset-replid-1) != CONFIG_RUN_ID_SIZE) {
            serverLog(LL_WARNING,
                "Master replied with wrong +FULLRESYNC syntax.");
            /* This is an unexpected condition, actually the +FULLRESYNC
             * reply means that the master supports PSYNC, but the reply
             * format seems wrong. To stay safe we blank the master
             * replid to make sure next PSYNCs will fail. */
            memset(server.master_replid,0,CONFIG_RUN_ID_SIZE+1);
        } else {
            memcpy(server.master_replid, replid, offset-replid-1);
            server.master_replid[CONFIG_RUN_ID_SIZE] = '\0';//对应主节点server.replid
            server.master_initial_offset = strtoll(offset,NULL,10);//对应主节点server.master_repl_offset
            serverLog(LL_NOTICE,"Full resync from master: %s:%lld",
                server.master_replid,
                server.master_initial_offset);
        }
        sdsfree(reply);
        return PSYNC_FULLRESYNC;
    }

    if (!strncmp(reply,"+CONTINUE",9)) {//返回+CONTINUE表明主节点同意部分同步
        /* Partial resync was accepted. */
        serverLog(LL_NOTICE,
            "Successful partial resynchronization with master.");

        /* Check the new replication ID advertised by the master. If it
         * changed, we need to set the new ID as primary ID, and set
         * secondary ID as the old master ID up to the current offset, so
         * that our sub-slaves will be able to PSYNC with us after a
         * disconnection. */
        char *start = reply+10;
        char *end = reply+9;
        while(end[0] != '\r' && end[0] != '\n' && end[0] != '\0') end++;
        if (end-start == CONFIG_RUN_ID_SIZE) {
            char new[CONFIG_RUN_ID_SIZE+1];
            memcpy(new,start,CONFIG_RUN_ID_SIZE);
            new[CONFIG_RUN_ID_SIZE] = '\0';

            if (strcmp(new,server.cached_master->replid)) {//这里判读主节点id与缓存的id是否一致
                /* Master ID changed. */
                serverLog(LL_NOTICE,"Master replication ID changed to %s",new);

                /* Set the old ID as our ID2, up to the current offset+1. *///保存server.cached_master->replid用于PSYNC2
                memcpy(server.replid2,server.cached_master->replid,
                    sizeof(server.replid2));
                server.second_replid_offset = server.master_repl_offset+1;

                /* Update the cached master ID and our own primary ID to the
                 * new one. *///更新server.replid以及server.cached_master->replid为newid
                memcpy(server.replid,new,sizeof(server.replid));
                memcpy(server.cached_master->replid,new,sizeof(server.replid));

                /* Disconnect all the sub-slaves: they need to be notified. */
                disconnectSlaves();//断开与所有从节点的连接，强制从节点重新同步
            }
        }

        /* Setup the replication to continue. */
        sdsfree(reply);
        replicationResurrectCachedMaster(conn);//这里执行的逻辑为：1.将当前的server.cached_master转换为server.master；2.为conn注册读事件处理函数readQueryFromClient用于处理主节点传播的命令；3.将server.repl_state转换为REPL_STATE_CONNECTED

        /* If this instance was restarted and we read the metadata to
         * PSYNC from the persistence file, our replication backlog could
         * be still not initialized. Create it. */
        if (server.repl_backlog == NULL) createReplicationBacklog();//初始化从节点的复制积压区
        return PSYNC_CONTINUE;//返回PSYNC_CONTINUE，进入主从复制阶段
    }

    /* If we reach this point we received either an error (since the master does
     * not understand PSYNC or because it is in a special state and cannot
     * serve our request), or an unexpected reply from the master.
     *
     * Return PSYNC_NOT_SUPPORTED on errors we don't understand, otherwise
     * return PSYNC_TRY_LATER if we believe this is a transient error. */

    if (!strncmp(reply,"-NOMASTERLINK",13) ||
        !strncmp(reply,"-LOADING",8))
    {
        serverLog(LL_NOTICE,
            "Master is currently unable to PSYNC "
            "but should be in the future: %s", reply);
        sdsfree(reply);
        return PSYNC_TRY_LATER;
    }

    if (strncmp(reply,"-ERR",4)) {
        /* If it's not an error, log the unexpected event. */
        serverLog(LL_WARNING,
            "Unexpected reply to PSYNC from master: %s", reply);
    } else {
        serverLog(LL_NOTICE,
            "Master does not support PSYNC or is in "
            "error state (reply: %s)", reply);
    }
    sdsfree(reply);
    return PSYNC_NOT_SUPPORTED;
}
```

`syncWithMaster` 中会根据 `slaveTryPartialResynchronization` 的返回值进行后续处理

+ PSYNC_WAIT_REPLY：等待下次对 syncWithMaster 的调用
+ PSYNC_TRY_LATER：主节点暂时无法进行主从同步，从节点状态转换为 REPL_STATE_CONNECT 等待下一次重新同步
+ PSYNC_CONTINUE：部分同步成功，从节点进入复制阶段
+ PSYNC_NOT_SUPPORTED：主节点不支持PSYNC协议，从节点回退到SYNC协议进行同步
+ PSYNC_WRITE_ERROR：打印错误日志，从节点状态转换为 REPL_STATE_CONNECT 等待下一次重新同步
+ PSYNC_FULLRESYNC：主节点要求全量同步，从节点将conn的读事件回调函数设置为 readSyncBulkPayload 进行全量同步，同时从节点状态转换为 REPL_STATE_TRANSFER

### 全量同步

在 `syncWithMaster` 中，如果主节点要求进行全量同步，此时 redis 会将主从连接的读事件处理函数注册为 `readSyncBulkPayload` 开始全量同步

```C
//src/replication.c
void readSyncBulkPayload(connection *conn)
{
    if (server.repl_transfer_size == -1)//第一次调用需要读取待接收的数据长度或者EOF标识
    {
        nread = connSyncReadLine(conn, buf, 1024, server.repl_syncio_timeout * 1000);
        if (nread == -1)
        {
            serverLog(LL_WARNING,
                      "I/O error reading bulk count from MASTER: %s",
                      connGetLastError(conn));
            goto error;
        }
        else
       /*...*/
            
        /*
        	主节点发送的数据有两种格式：
        	1. $<count> 这种是先发送总的数据长度，再发送数据
        	2. $EOF:<40 bytes delimiter> 这种是在无盘模式数据总长度未知的情况下发送一个40字节的随机字节数组作为结束符
        	usemark 用来区分这两种格式
        */
        if (strncmp(buf + 1, "EOF:", 4) == 0 && strlen(buf + 5) >= CONFIG_RUN_ID_SIZE)
        {
            usemark = 1;
            memcpy(eofmark, buf + 5, CONFIG_RUN_ID_SIZE);
            memset(lastbytes, 0, CONFIG_RUN_ID_SIZE);
            /* Set any repl_transfer_size to avoid entering this code path
             * at the next call. */
            server.repl_transfer_size = 0;
            serverLog(LL_NOTICE,
                      "MASTER <-> REPLICA sync: receiving streamed RDB from master with EOF %s",
                      use_diskless_load ? "to parser" : "to disk");
        }
        else
        {
            usemark = 0;
            server.repl_transfer_size = strtol(buf + 1, NULL, 10);
            serverLog(LL_NOTICE,
                      "MASTER <-> REPLICA sync: receiving %lld bytes from master %s",
                      (long long)server.repl_transfer_size,
                      use_diskless_load ? "to parser" : "to disk");
        }
        return;
    }
    
    /*
    	针对非无盘模式的情况需要先将主节点发送的数据落盘
    */
    if (!use_diskless_load)
    {
        /* Read the data from the socket, store it to a file and search
         * for the EOF. */
        if (usemark)
        {
            readlen = sizeof(buf);
        }
        else
        {
            left = server.repl_transfer_size - server.repl_transfer_read;
            readlen = (left < (signed)sizeof(buf)) ? left : (signed)sizeof(buf);
        }

        nread = connRead(conn, buf, readlen);//从主节点读取数据
        /*...*/
        if ((nwritten = write(server.repl_transfer_fd, buf, nread)) != nread)//写入临时文件server.repl_transfer_fd
        {
            serverLog(LL_WARNING,
                      "Write error or short write writing to the DB dump file "
                      "needed for MASTER <-> REPLICA synchronization: %s",
                      (nwritten == -1) ? strerror(errno) : "short write");
            goto error;
        }
        /*...*/
    }
    
    /*
    	执行到这里说明已经接收完整的主节点数据并写入文件，或者采用无盘模式
    */
    if (server.aof_state != AOF_OFF)//终止正在执行的AOF进程，避免CoW灾难
        stopAppendOnly();
    /* Also try to stop save RDB child before flushing and parsing the RDB:
     * 1. Ensure background save doesn't overwrite synced data after being loaded.
     * 2. Avoid copy-on-write disaster. */
    if (server.child_type == CHILD_TYPE_RDB)//终止正在执行的RDB进程，避免覆盖同步数据以及CoW灾难
    {
        if (!use_diskless_load)
        {
            serverLog(LL_NOTICE,
                      "Replica is about to load the RDB file received from the "
                      "master, but there is a pending RDB child running. "
                      "Killing process %ld and removing its temp file to avoid "
                      "any race",
                      (long)server.child_pid);
        }
        killRDBChild();
    }
	
    if (use_diskless_load && server.repl_diskless_load == REPL_DISKLESS_LOAD_SWAPDB)
    {
        /* Initialize empty tempDb dictionaries. */
        diskless_load_tempDb = disklessLoadInitTempDb();//如果使用无盘模式并且配置为REPL_DISKLESS_LOAD_SWAPDB，则将当前的数据库生成一个临时数据库diskless_load_tempDb
        temp_functions_lib_ctx = functionsLibCtxCreate();

        moduleFireServerEvent(REDISMODULE_EVENT_REPL_ASYNC_LOAD,
                              REDISMODULE_SUBEVENT_REPL_ASYNC_LOAD_STARTED,
                              NULL);
    }
    else
    {
        replicationAttachToNewMaster();//这里已经确定当前从节点要加载从主节点获取的数据，即数据库加载全新的数据，此时与本节点的从节点之间的增量同步已经不可行，这里直接通知所有从节点重新同步

        serverLog(LL_NOTICE, "MASTER <-> REPLICA sync: Flushing old data");
        emptyData(-1, empty_db_flags, replicationEmptyDbCallback);//不采用无盘模式则清空数据库
    }
    
    /*开始加载*/
    if (use_diskless_load)//无盘模式
    {
        rio rdb;
        redisDb *dbarray;
        functionsLibCtx *functions_lib_ctx;
        int asyncLoading = 0;

        if (server.repl_diskless_load == REPL_DISKLESS_LOAD_SWAPDB)
        {
            /* 在进行完全重新同步期间，异步加载意味着我们可以继续提供读取命令的服务，并且只有在加载完成后才将新数据库与旧数据库“交换”。异步加载仅在SWAPDB磁盘无盘复制时启用，当主复制ID未更改时，因为在这种状态下，数据库的旧内容代表我们当前从主节点接收到的相同数据集的不同时间点。异步加载允许Redis服务器在进行完全重新同步期间继续处理读取命令，而不会中断对客户端的服务。这对于通过磁盘无盘复制方式进行数据同步时特别有用，在这种情况下，旧数据库的内容代表了相同数据集的不同时间点，因此需要特殊处理*/
            if (memcmp(server.replid, server.master_replid, CONFIG_RUN_ID_SIZE) == 0)
            {
                asyncLoading = 1;
            }
            dbarray = diskless_load_tempDb;//使用临时数据库
            functions_lib_ctx = temp_functions_lib_ctx;
        }
        else
        {
            dbarray = server.db;//使用当前数据库
            functions_lib_ctx = functionsLibCtxGetCurrent();
            functionsLibCtxClear(functions_lib_ctx);
        }

        rioInitWithConn(&rdb, conn, server.repl_transfer_size);

        /* Put the socket in blocking mode to simplify RDB transfer.
         * We'll restore it when the RDB is received. */
        connBlock(conn);
        connRecvTimeout(conn, server.repl_timeout * 1000);
        startLoading(server.repl_transfer_size, RDBFLAGS_REPLICATION, asyncLoading);

        int loadingFailed = 0;
        rdbLoadingCtx loadingCtx = {.dbarray = dbarray, .functions_lib_ctx = functions_lib_ctx};
        if (rdbLoadRioWithLoadingCtx(&rdb, RDBFLAGS_REPLICATION, &rsi, &loadingCtx) != C_OK)//从主节点接收数据并加载
        {
            /* RDB loading failed. */
            serverLog(LL_WARNING,
                      "Failed trying to load the MASTER synchronization DB "
                      "from socket, check server logs.");
            loadingFailed = 1;
        }
        else if (usemark)
        {
            /* Verify the end mark is correct. */
            if (!rioRead(&rdb, buf, CONFIG_RUN_ID_SIZE) ||
                memcmp(buf, eofmark, CONFIG_RUN_ID_SIZE) != 0)
            {
                serverLog(LL_WARNING, "Replication stream EOF marker is broken");
                loadingFailed = 1;
            }
        }

        if (loadingFailed)//加载失败处理：如果采用了临时db则将其丢弃；否则清空数据库
        {
           /*...*/
            return;
        }

        /* RDB loading succeeded if we reach this point. */
        if (server.repl_diskless_load == REPL_DISKLESS_LOAD_SWAPDB)//加载成功，交换临时db与主db
        {
            /* We will soon swap main db with tempDb and replicas will start
             * to apply data from new master, we must discard the cached
             * master structure and force resync of sub-replicas. */
            replicationAttachToNewMaster();

            serverLog(LL_NOTICE, "MASTER <-> REPLICA sync: Swapping active DB with loaded DB");
            swapMainDbWithTempDb(diskless_load_tempDb);

            /* swap existing functions ctx with the temporary one */
            functionsLibCtxSwapWithCurrent(temp_functions_lib_ctx);

            moduleFireServerEvent(REDISMODULE_EVENT_REPL_ASYNC_LOAD,
                                  REDISMODULE_SUBEVENT_REPL_ASYNC_LOAD_COMPLETED,
                                  NULL);

            /* Delete the old db as it's useless now. */
            disklessLoadDiscardTempDb(diskless_load_tempDb);
            serverLog(LL_NOTICE, "MASTER <-> REPLICA sync: Discarding old DB in background");
        }

        /* Inform about db change, as replication was diskless and didn't cause a save. */
        server.dirty++;

        stopLoading(1);

        /* Cleanup and restore the socket to the original state to continue
         * with the normal replication. */
        rioFreeConn(&rdb, NULL);
        connNonBlock(conn);
        connRecvTimeout(conn, 0);
    }
    else
    {

        /* Make sure the new file (also used for persistence) is fully synced
         * (not covered by earlier calls to rdb_fsync_range). */
        /*...*/

        /* Rename rdb like renaming rewrite aof asynchronously. */
        int old_rdb_fd = open(server.rdb_filename, O_RDONLY | O_NONBLOCK);
        if (rename(server.repl_transfer_tmpfile, server.rdb_filename) == -1)//将临时文件重命名为server.rdb_filename
        {
            /*...*/
        }

        if (rdbLoad(server.rdb_filename, &rsi, RDBFLAGS_REPLICATION) != RDB_OK)//加载数据文件
        {
            
            /*...*/
            /* Note that there's no point in restarting the AOF on sync failure,
               it'll be restarted when sync succeeds or replica promoted. */
            return;
        }

        /* Cleanup. */
        
    }
    
    /* Final setup of the connected slave <- master link */
    replicationCreateMasterClient(server.repl_transfer_s, rsi.repl_stream_db);//在与主节点建立连接并进行同步后，该函数从指定文件描述符开始创建server.master中存储的主节点客户端；该函数将 server.master_replid 拷贝到 server.master->replid，将 server.master_initial_offset 拷贝到 server.master->reploff
    server.repl_state = REPL_STATE_CONNECTED;//更新从节点状态，进入复制模式
    server.repl_down_since = 0;

    /* Fire the master link modules event. */
    moduleFireServerEvent(REDISMODULE_EVENT_MASTER_LINK_CHANGE,
                          REDISMODULE_SUBEVENT_MASTER_LINK_UP,
                          NULL);

    /* After a full resynchronization we use the replication ID and
     * offset of the master. The secondary ID / offset are cleared since
     * we are starting a new history. */
    memcpy(server.replid, server.master->replid, sizeof(server.replid));//这里将主节点id保存到从节点的server.replid
    server.master_repl_offset = server.master->reploff;//主节点的reploff保存到从节点的master_repl_offset
    clearReplicationId2();

    /* Let's create the replication backlog if needed. Slaves need to
     * accumulate the backlog regardless of the fact they have sub-slaves
     * or not, in order to behave correctly if they are promoted to
     * masters after a failover. */
    if (server.repl_backlog == NULL)
        createReplicationBacklog();
    serverLog(LL_NOTICE, "MASTER <-> REPLICA sync: Finished with success");

    if (server.supervised_mode == SUPERVISED_SYSTEMD)
    {
        redisCommunicateSystemd("STATUS=MASTER <-> REPLICA sync: Finished with success. Ready to accept connections in read-write mode.\n");
    }

    /* Send the initial ACK immediately to put this replica in online state. */
    if (usemark)
        replicationSendAck();

    /* Restart the AOF subsystem now that we finished the sync. This
     * will trigger an AOF rewrite, and when done will start appending
     * to the new file. */
    if (server.aof_enabled)
        restartAOFAfterSYNC();
    return;

error:
    cancelReplicationHandshake(1);
    return;
}
```

## 主节点同步流程

主节点接收从节点发送的 PSYNC 或者 SYNC 命令，命令处理函数为 `syncCommand`

```C
//src/replication.c
void syncCommand(client *c)
{
    if (!strcasecmp(c->argv[0]->ptr, "psync"))//处理psync命令
    {
        long long psync_offset;
        if (getLongLongFromObjectOrReply(c, c->argv[2], &psync_offset, NULL) != C_OK)
        {
            serverLog(LL_WARNING, "Replica %s asks for synchronization but with a wrong offset",
                      replicationGetSlaveName(c));
            return;
        }

        if (masterTryPartialResynchronization(c, psync_offset) == C_OK)//尝试进行部分同步操作，成功则退出，否则继续执行
        {
            server.stat_sync_partial_ok++;
            return; /* No full resync needed, return. */
        }
        else
        {
            char *master_replid = c->argv[1]->ptr;

            /* Increment stats for failed PSYNCs, but only if the
             * replid is not "?", as this is used by slaves to force a full
             * resync on purpose when they are not able to partially
             * resync. */
            if (master_replid[0] != '?')
                server.stat_sync_partial_err++;
        }
    }
    else
    {
        /* If a slave uses SYNC, we are dealing with an old implementation
         * of the replication protocol (like redis-cli --slave). Flag the client
         * so that we don't expect to receive REPLCONF ACK feedbacks. */
        c->flags |= CLIENT_PRE_PSYNC;
    }
    
    /* Full resynchronization. */
    server.stat_sync_full++;//执行到这里说明无法进行部分同步，需要进行全量同步

    /* Setup the slave as one waiting for BGSAVE to start. The following code
     * paths will change the state if we handle the slave differently. */
    c->replstate = SLAVE_STATE_WAIT_BGSAVE_START;//更新从节点状态为 SLAVE_STATE_WAIT_BGSAVE_START
    if (server.repl_disable_tcp_nodelay)
        connDisableTcpNoDelay(c->conn); /* Non critical if it fails. */
    c->repldbfd = -1;
    c->flags |= CLIENT_SLAVE;
    listAddNodeTail(server.slaves, c);//从节点添加到 server.slaves

    /* Create the replication backlog if needed. */
    if (listLength(server.slaves) == 1 && server.repl_backlog == NULL)//第一次作为其他节点的主节点，创建相关数据结构，包括复制积压区、server.replid、server.replid2
    {
        /* When we create the backlog from scratch, we always use a new
         * replication ID and clear the ID2, since there is no valid
         * past history. */
        changeReplicationId();
        clearReplicationId2();
        createReplicationBacklog();
        serverLog(LL_NOTICE, "Replication backlog created, my new "
                             "replication IDs are '%s' and '%s'",
                  server.replid, server.replid2);
    }
    /*
    	执行到这里，主节点需要生成RDB文件，并发送给从节点处理，分成三种情况
    	1）当前正在生成RDB文件并且写入磁盘，如果slave列表中存在其他处于SLAVE_STATE_WAIT_BGSAVE_END状态的slave，说明当前正在生成的RDB文件也可以被正在处理的slave使用，修改当前slave状态为SLAVE_STATE_WAIT_BGSAVE_END，直接使用当前生成的RDB文件
    	2）主节点正在生成RDB数据并且直接通过scoket发送，此时需要等待当前RDB操作完成后再进行同步
    	3）不存在子其他进程，调用startBgsaveForReplication生成RDB文件
    */
}
```

### 全量同步

`startBgsaveForReplication` 负责生成RDB数据并发送给从节点

```C
//src/replication.c
int startBgsaveForReplication(int mincapa, int req)
{
    socket_target = (server.repl_diskless_sync || req & SLAVE_REQ_RDB_MASK) && (mincapa & SLAVE_CAPA_EOF);

    if (rsiptr)
    {
        if (socket_target)//如果采用无盘同步的方式则调用rdbSaveToSlavesSockets生成RDB数据并直接发送到scoket中，否则调用rdbSaveBackground生成RDB文件
            retval = rdbSaveToSlavesSockets(req, rsiptr);//逻辑为：1）向所有处于SLAVE_STATE_WAIT_BGSAVE_START的从节点发送+FULLRESYNC <server.replid> <server.master_repl_offset>；2）创建子进程生成RDB数据，生成的数据通过管道server.rdb_pipe_read发送给主进程；3）主进程为server.rdb_pipe_read注册读事件处理函数rdbPipeReadHandler；3）在rdbPipeReadHandler中，从server.rdb_pipe_read读取数据并存放到缓冲区，遍历server.rdb_pipe_conns（数组，每一个元素对应一个从节点连接conn）并写入，如果一次写不完则为conn注册写事件处理函数rdbPipeWriteHandler待下次调用
        else
        {
            /* Keep the page cache since it'll get used soon *///否则生成RDB文件
            retval = rdbSaveBackground(req, server.rdb_filename, rsiptr, RDBFLAGS_KEEP_CACHE);
        }
    }
    else
    {
        serverLog(LL_WARNING, "BGSAVE for replication: replication information not available, can't generate the RDB file right now. Try later.");
        retval = C_ERR;
    }
    
    if (!socket_target)//如果不采用无盘模式，则遍历所有从节点，对状态处于SLAVE_STATE_WAIT_BGSAVE_START的从节点调用replicationSetupSlaveForFullResync，该函数的逻辑为：1）将从节点状态切换为SLAVE_STATE_WAIT_BGSAVE_END；2）向从节点发送 +FULLRESYNC <server.replid> <server.master_repl_offset>
    {
        listRewind(server.slaves, &li);
        while ((ln = listNext(&li)))
        {
            client *slave = ln->value;

            if (slave->replstate == SLAVE_STATE_WAIT_BGSAVE_START)
            {
                /* Check slave has the exact requirements */
                if (slave->slave_req != req)
                    continue;
                replicationSetupSlaveForFullResync(slave, getPsyncInitialOffset());
            }
        }
    }
}
```

生成RDB文件后，还需要将RDB文件发送给从节点，该工作在serverCron中进行，调用链为 `serverCron->checkChildrenDone->backgroundSaveDoneHandler->updateSlavesWaitingBgsave` 

```C
//src/replication.c
void updateSlavesWaitingBgsave(int bgsaveerr, int type)
{
    listNode *ln;
    listIter li;

    /* Note: there's a chance we got here from within the REPLCONF ACK command
     * so we must avoid using freeClient, otherwise we'll crash on our way up. */

    listRewind(server.slaves, &li);
    while ((ln = listNext(&li)))
    {
        client *slave = ln->value;

        if (slave->replstate == SLAVE_STATE_WAIT_BGSAVE_END)//遍历所有状态为SLAVE_STATE_WAIT_BGSAVE_END的从节点
        {
            struct redis_stat buf;

            if (bgsaveerr != C_OK)
            {
                freeClientAsync(slave);
                serverLog(LL_WARNING, "SYNC failed. BGSAVE child returned an error");
                continue;
            }

            /* If this was an RDB on disk save, we have to prepare to send
             * the RDB from disk to the slave socket. Otherwise if this was
             * already an RDB -> Slaves socket transfer, used in the case of
             * diskless replication, our work is trivial, we can just put
             * the slave online. */
            if (type == RDB_CHILD_TYPE_SOCKET)
            {
                serverLog(LL_NOTICE,
                          "Streamed RDB transfer with replica %s succeeded (socket). Waiting for REPLCONF ACK from replica to enable streaming",
                          replicationGetSlaveName(slave));
               
                if (!replicaPutOnline(slave))//如果从节点是直接通过socket发送RDB文件，那么执行到这里说明从节点完成了数据接收，将从节点状态更新为SLAVE_STATE_ONLINE
                {
                    freeClientAsync(slave);
                    continue;
                }
                slave->repl_start_cmd_stream_on_ack = 1;
            }
            else
            {//执行到这里，说明是先生成RDB文件，再发送给从节点，这里注册从节点连接conn的写事件处理函数为sendBulkToSlave，
                if ((slave->repldbfd = open(server.rdb_filename, O_RDONLY)) == -1 ||
                    redis_fstat(slave->repldbfd, &buf) == -1)
                {
                    freeClientAsync(slave);
                    serverLog(LL_WARNING, "SYNC failed. Can't open/stat DB after BGSAVE: %s", strerror(errno));
                    continue;
                }
                slave->repldboff = 0;
                slave->repldbsize = buf.st_size;
                slave->replstate = SLAVE_STATE_SEND_BULK;//从节点状态更新为SLAVE_STATE_SEND_BULK
                slave->replpreamble = sdscatprintf(sdsempty(), "$%lld\r\n",
                                                   (unsigned long long)slave->repldbsize);

                connSetWriteHandler(slave->conn, NULL);
                if (connSetWriteHandler(slave->conn, sendBulkToSlave) == C_ERR)
                {
                    freeClientAsync(slave);
                    continue;
                }
            }
        }
    }
}

//src/replication.c
void sendBulkToSlave(connection *conn)
{
    client *slave = connGetPrivateData(conn);
    char buf[PROTO_IOBUF_LEN];
    ssize_t nwritten, buflen;

    /* Before sending the RDB file, we send the preamble as configured by the
     * replication process. Currently the preamble is just the bulk count of
     * the file in the form "$<length>\r\n". */
    if (slave->replpreamble)//首先，发送数据长度
    {
        nwritten = connWrite(conn, slave->replpreamble, sdslen(slave->replpreamble));
        /*....*/
    }

    /* If the preamble was already transferred, send the RDB bulk data. */
    lseek(slave->repldbfd, slave->repldboff, SEEK_SET);
    buflen = read(slave->repldbfd, buf, PROTO_IOBUF_LEN);//从RDB文件读取数据
    if (buflen <= 0)
    {
        serverLog(LL_WARNING, "Read error sending DB to replica: %s",
                  (buflen == 0) ? "premature EOF" : strerror(errno));
        freeClient(slave);
        return;
    }
    if ((nwritten = connWrite(conn, buf, buflen)) == -1)//发送给从节点
    {
        /*....*/
        return;
    }
    slave->repldboff += nwritten;
    atomicIncr(server.stat_net_repl_output_bytes, nwritten);
    if (slave->repldboff == slave->repldbsize)//发送完成，则调用replicaPutOnline变更从节点状态
    {
        closeRepldbfd(slave);
        connSetWriteHandler(slave->conn, NULL);
        if (!replicaPutOnline(slave))
        {
            freeClient(slave);
            return;
        }
        replicaStartCommandStream(slave);
    }
}
```

### 部分同步

在 syncCommand 中，redis 会调用 masterTryPartialResynchronization 尝试进行部分同步

```C
//src/replication.c
int masterTryPartialResynchronization(client *c, long long psync_offset)
{
    long long psync_len;
    char *master_replid = c->argv[1]->ptr;//从节点命令参数中的replid
    char buf[128];
    int buflen;

    /* Is the replication ID of this master the same advertised by the wannabe
     * slave via PSYNC? If the replication ID changed this master has a
     * different replication history, and there is no way to continue.
     *
     * Note that there are two potentially valid replication IDs: the ID1
     * and the ID2. The ID2 however is only valid up to a specific offset. */
    if (strcasecmp(master_replid, server.replid) &&//如果从节点的replid与主节点的replid和ireplid2都不相等或者psync_offset > server.second_replid_offset都会导致部分同步失败
        (strcasecmp(master_replid, server.replid2) ||
         psync_offset > server.second_replid_offset))
    {
        /* Replid "?" is used by slaves that want to force a full resync. */
        if (master_replid[0] != '?')
        {
            /*...*/
        goto need_full_resync;
    }

    /* We still have the data our slave is asking for? */
    if (!server.repl_backlog ||//检查从节点请求的偏移量是否在当前复制积压区之间，不在则部分同步失败
        psync_offset < server.repl_backlog->offset ||
        psync_offset > (server.repl_backlog->offset + server.repl_backlog->histlen))
    {
        /*...*/
        goto need_full_resync;
    }

    /* If we reached this point, we are able to perform a partial resync:
     * 1) Set client state to make it a slave.
     * 2) Inform the client we can continue with +CONTINUE
     * 3) Send the backlog data (from the offset to the end) to the slave. */
    c->flags |= CLIENT_SLAVE;
    c->replstate = SLAVE_STATE_ONLINE;//修改从节点状态为SLAVE_STATE_ONLINE
    c->repl_ack_time = server.unixtime;
    c->repl_start_cmd_stream_on_ack = 0;
    listAddNodeTail(server.slaves, c);
    /* We can't use the connection buffers since they are used to accumulate
     * new commands at this stage. But we are sure the socket send buffer is
     * empty so this write will never fail actually. */
    if (c->slave_capa & SLAVE_CAPA_PSYNC2)//向从节点发送+CONTINUE表明从节点可以继续进行部分同步
    {
        buflen = snprintf(buf, sizeof(buf), "+CONTINUE %s\r\n", server.replid);
    }
    else
    {
        buflen = snprintf(buf, sizeof(buf), "+CONTINUE\r\n");
    }
    if (connWrite(c->conn, buf, buflen) != buflen)
    {
        freeClientAsync(c);
        return C_OK;
    }
    psync_len = addReplyReplicationBacklog(c, psync_offset);//根据psync_offset获取复制积压区中需要给该从节点发送的内容，然后调用prepareClientToWrite将当前从节点添加到server.clients_pending_write列表中
    serverLog(LL_NOTICE,
              "Partial resynchronization request from %s accepted. Sending %lld bytes of backlog starting from offset %lld.",
              replicationGetSlaveName(c),
              psync_len, psync_offset);
    /* Note that we don't need to set the selected DB at server.slaveseldb
     * to -1 to force the master to emit SELECT, since the slave already
     * has this state from the previous connection with the master. */

    refreshGoodSlavesCount();

    /* Fire the replica change modules event. */
    moduleFireServerEvent(REDISMODULE_EVENT_REPLICA_CHANGE,
                          REDISMODULE_SUBEVENT_REPLICA_CHANGE_ONLINE,
                          NULL);

    return C_OK; /* The caller can return, no full resync needed. */

need_full_resync:
    /* We need a full resync for some reason... Note that we can't
     * reply to PSYNC right now if a full SYNC is needed. The reply
     * must include the master offset at the time the RDB file we transfer
     * is generated, so we need to delay the reply to that moment. */
    return C_ERR;
}
```

### 主节点命令复制

在主节点中，每执行一条命令，都会通过 replicationFeedSlaves->feedReplicationBuffer 将其写入积压缓冲区（在call->afterCommand->postExecutionUnitOperations->propagatePendingCommands->propagateNow中触发），每次写入命令都会将 `server.master_repl_offset` 增加对应的长度

### 部分同步中的id与offset

PSYNC命令需要用到replid与offset两个参数，分别存放在主节点和从节点的server.replid、server.master_repl_offset中，从节点的server.master.replid、server.master.reploffset也存放了一份。主从同步正常工作需要主从节点的这两个参数保持一致。

首先，在全量同步的过程中，这两个属性由主节点传递给从节点

1) 主节点调用 replicationSetupSlaveForFullResync 发送 `+FULLRESYNC <server.replid> <server.master_repl_offset>`
2) 从节点调用 slaveTryPartialResynchronization 解析 id 和 offset 并保存到 server.master_replid、server.master_initial_offset 中
3) 从节点调用 readSyncBulkPayload->replicationCreateMasterClient 将上一步保存的 id 和 offset 保存到 server.master->replid 和 server.master->reploff，然后调用再保存到 server.replid 和 server.master_repl_offset 中

至此，主从节点的相关属性达成一致。

在主从复制阶段，主节点每传播一条命令，都会将 `server.master_repl_offset` 增加对应的长度。同样地，从节点每接收一条命令，都会将 `server.master->reploff` 和 ` server.master_repl_offset` 增加对应的长度，其中，`server.master->reploff` 在 commandProcessed 中更新，` server.master_repl_offset` 在 replicationFeedStreamFromMasterStream->feedReplicationBuffer 中更新

```C
//src/networking.c
void commandProcessed(client *c) {
    /* If client is blocked(including paused), just return avoid reset and replicate.
     *
     * 1. Don't reset the client structure for blocked clients, so that the reply
     *    callback will still be able to access the client argv and argc fields.
     *    The client will be reset in unblockClient().
     * 2. Don't update replication offset or propagate commands to replicas,
     *    since we have not applied the command. */
    if (c->flags & CLIENT_BLOCKED) return;

    reqresAppendResponse(c);
    resetClient(c);

    long long prev_offset = c->reploff;
    if (c->flags & CLIENT_MASTER && !(c->flags & CLIENT_MULTI)) {//条件成立说明c就是主节点客户端server.master，这里相当于更新server.master->reploff
        /* Update the applied replication offset of our master. */
        c->reploff = c->read_reploff - sdslen(c->querybuf) + c->qb_pos;//等价于c->read_reploff - (sdslen(c->querybuf) - c->qb_pos)，可以理解为已经读取的偏移量减去未执行的命令的长度即为从节点已经执行的偏移量
    }

    /* If the client is a master we need to compute the difference
     * between the applied offset before and after processing the buffer,
     * to understand how much of the replication stream was actually
     * applied to the master state: this quantity, and its corresponding
     * part of the replication stream, will be propagated to the
     * sub-replicas and to the replication backlog. */
    if (c->flags & CLIENT_MASTER) {
        long long applied = c->reploff - prev_offset;
        if (applied) {
            replicationFeedStreamFromMasterStream(c->querybuf+c->repl_applied,applied);//这里更新server.master_repl_offset
            c->repl_applied += applied;
        }
    }
}
```

## 定时逻辑

replicationCron 由 serverCron 触发，用于执行主从复制相关逻辑，主要包括以下逻辑：

1. 从节点握手阶段超时检查，超时则取消当前握手并重新进入 REPL_STATE_CONNECT 状态并重连
2. 从节点RDB数据传输阶段超时检查，超时则重新进入 REPL_STATE_CONNECT 状态并重连
3. 判断上次收到主节点数据的时间server.master->lastinteraction与当前时间的差是否超过server.repl_timeout，超过则认为主节点失效，断开主节点客户端，状态改为 REPL_STATE_CONNECT
4. 检查当前节点是否处于 REPL_STATE_CONNECT 状态，是则调用 connectWithMaster
5. 从节点向主节点发送 server.master->reploff，主节点受到后更新 client.repl_ack_time、client.repl_ack_off
6. 主节点向所有从节点发送 PING
7. 主节点检查从节点是否超时（server.unixtime - slave->repl_ack_time) > server.repl_timeout），超时则断开与该节点的连接
8. 如果从节点数量为0，主节点检查空闲时间（从没有从节点开始）是否超过 server.repl_backlog_time_limit，超过则删除复制积压区，并生成新的  replid，清除 replid2
9. 主节点检查是否存在处于 WAIT_BGSAVE_START 状态的从节点，如果存在并且当前没有子进程，则调用 startBgsaveForReplication 生成RDB数据
10. 主节点维护了 server.repl_good_slaves_count 用于记录好的从节点的数量，这里进行更新

